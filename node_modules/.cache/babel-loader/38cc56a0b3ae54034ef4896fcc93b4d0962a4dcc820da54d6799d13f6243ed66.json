{"ast":null,"code":"const BACKEND_URL = 'http://localhost:3001';\nconsole.log('SocialService Debug:');\nconsole.log('Backend URL:', BACKEND_URL);\nconsole.log('Using real social media data via backend server (Reddit scraping)');\nconst analyzeSentiment = text => {\n  // Simple sentiment analysis based on keyword matching\n  // In a production environment, you'd want to use a proper NLP service\n  const positiveWords = ['great', 'good', 'awesome', 'excellent', 'up', 'gain', 'profit', 'bull'];\n  const negativeWords = ['bad', 'poor', 'terrible', 'down', 'loss', 'bear', 'crash', 'decline'];\n  const words = text.toLowerCase().split(/\\s+/);\n  let score = 0;\n  let positiveCount = 0;\n  let negativeCount = 0;\n  words.forEach(word => {\n    if (positiveWords.includes(word)) positiveCount++;\n    if (negativeWords.includes(word)) negativeCount++;\n  });\n  score = (positiveCount - negativeCount) / (positiveCount + negativeCount || 1);\n  return {\n    score: Math.max(-1, Math.min(1, score)),\n    // Clamp between -1 and 1\n    label: score > 0.1 ? 'positive' : score < -0.1 ? 'negative' : 'neutral',\n    confidence: Math.abs(score)\n  };\n};\nexport const socialService = {\n  async getSocialPosts(searchTerm) {\n    try {\n      console.log(`Fetching real social media data for term: ${searchTerm}`);\n\n      // Call the backend API for real social media data from Reddit\n      const response = await fetch(`${BACKEND_URL}/api/social/${encodeURIComponent(searchTerm)}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      console.log('Backend response status:', response.status);\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({\n          error: 'Unknown error'\n        }));\n        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);\n      }\n      const socialPosts = await response.json();\n      console.log(`Received ${socialPosts.length} real social media posts for ${searchTerm}`);\n\n      // Convert Reddit posts to social post format for compatibility\n      const realSocialPosts = socialPosts.map((post, index) => {\n        var _post$sentiment, _post$sentiment2;\n        return {\n          id: post.id || index.toString(),\n          text: post.text,\n          description: post.description,\n          author: post.author,\n          createdAt: post.createdAt,\n          source: post.source,\n          url: post.url,\n          score: post.score,\n          platform: 'reddit',\n          sentiment: {\n            label: ((_post$sentiment = post.sentiment) === null || _post$sentiment === void 0 ? void 0 : _post$sentiment.label) || 'neutral',\n            score: ((_post$sentiment2 = post.sentiment) === null || _post$sentiment2 === void 0 ? void 0 : _post$sentiment2.score) || 0\n          },\n          aiSummary: post.aiSummary\n        };\n      });\n      console.log(`Returning ${realSocialPosts.length} real social media posts`);\n      return realSocialPosts;\n\n      // TODO: Uncomment below when Twitter API access is properly configured\n      /*\n      // Calculate start_time based on timeRange\n      const now = new Date();\n      const startTime = new Date(now.getTime());\n      \n      switch (timeRange) {\n        case '1h':\n          startTime.setHours(now.getHours() - 1);\n          break;\n        case '24h':\n          startTime.setDate(now.getDate() - 1);\n          break;\n        case '7d':\n          startTime.setDate(now.getDate() - 7);\n          break;\n        case '30d':\n          startTime.setDate(now.getDate() - 30);\n          break;\n      }\n       const response = await axios.get(`${TWITTER_API_BASE_URL}/tweets/search/recent`, {\n        headers: {\n          'Authorization': `Bearer ${TWITTER_API_KEY}`,\n        },\n        params: {\n          query: searchTerm,\n          'start_time': startTime.toISOString(),\n          'tweet.fields': 'created_at,author_id',\n          'user.fields': 'username',\n          'max_results': 100,\n        },\n      });\n       return response.data.data.map((tweet: any) => ({\n        id: tweet.id,\n        text: tweet.text,\n        created_at: tweet.created_at,\n        author_username: tweet.author_id, // In real implementation, we'd get the actual username\n        sentiment: analyzeSentiment(tweet.text),\n      }));\n      */\n    } catch (error) {\n      console.error('Error fetching social media data:', error);\n      if (error.message.includes('fetch') || error.name === 'TypeError') {\n        throw new Error('Backend server is not running. Please start the backend server on port 3001.');\n      }\n      throw new Error(`Failed to fetch social media data for ${searchTerm}: ${error.message}`);\n    }\n  }\n};","map":{"version":3,"names":["BACKEND_URL","console","log","analyzeSentiment","text","positiveWords","negativeWords","words","toLowerCase","split","score","positiveCount","negativeCount","forEach","word","includes","Math","max","min","label","confidence","abs","socialService","getSocialPosts","searchTerm","response","fetch","encodeURIComponent","method","headers","status","ok","errorData","json","catch","error","Error","statusText","socialPosts","length","realSocialPosts","map","post","index","_post$sentiment","_post$sentiment2","id","toString","description","author","createdAt","source","url","platform","sentiment","aiSummary","message","name"],"sources":["/Users/alexanderalmanza/current/src/services/socialService.ts"],"sourcesContent":["import { Tweet, SentimentScore } from '../types';\n\nconst BACKEND_URL = 'http://localhost:3001';\n\nconsole.log('SocialService Debug:');\nconsole.log('Backend URL:', BACKEND_URL);\nconsole.log('Using real social media data via backend server (Reddit scraping)');\n\nconst analyzeSentiment = (text: string): SentimentScore => {\n  // Simple sentiment analysis based on keyword matching\n  // In a production environment, you'd want to use a proper NLP service\n  const positiveWords = ['great', 'good', 'awesome', 'excellent', 'up', 'gain', 'profit', 'bull'];\n  const negativeWords = ['bad', 'poor', 'terrible', 'down', 'loss', 'bear', 'crash', 'decline'];\n\n  const words = text.toLowerCase().split(/\\s+/);\n  let score = 0;\n  let positiveCount = 0;\n  let negativeCount = 0;\n\n  words.forEach(word => {\n    if (positiveWords.includes(word)) positiveCount++;\n    if (negativeWords.includes(word)) negativeCount++;\n  });\n\n  score = (positiveCount - negativeCount) / (positiveCount + negativeCount || 1);\n  \n  return {\n    score: Math.max(-1, Math.min(1, score)), // Clamp between -1 and 1\n    label: score > 0.1 ? 'positive' : score < -0.1 ? 'negative' : 'neutral',\n    confidence: Math.abs(score),\n  };\n};\n\nexport const socialService = {\n  async getSocialPosts(searchTerm: string): Promise<Tweet[]> {\n    try {\n      console.log(`Fetching real social media data for term: ${searchTerm}`);\n      \n      // Call the backend API for real social media data from Reddit\n      const response = await fetch(`${BACKEND_URL}/api/social/${encodeURIComponent(searchTerm)}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      console.log('Backend response status:', response.status);\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));\n        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const socialPosts = await response.json();\n      console.log(`Received ${socialPosts.length} real social media posts for ${searchTerm}`);\n      \n      // Convert Reddit posts to social post format for compatibility\n      const realSocialPosts: Tweet[] = socialPosts.map((post: any, index: number) => ({\n        id: post.id || index.toString(),\n        text: post.text,\n        description: post.description,\n        author: post.author,\n        createdAt: post.createdAt,\n        source: post.source,\n        url: post.url,\n        score: post.score,\n        platform: 'reddit',\n        sentiment: {\n          label: post.sentiment?.label || 'neutral',\n          score: post.sentiment?.score || 0,\n        },\n        aiSummary: post.aiSummary,\n      }));\n\n      console.log(`Returning ${realSocialPosts.length} real social media posts`);\n      return realSocialPosts;\n      \n      // TODO: Uncomment below when Twitter API access is properly configured\n      /*\n      // Calculate start_time based on timeRange\n      const now = new Date();\n      const startTime = new Date(now.getTime());\n      \n      switch (timeRange) {\n        case '1h':\n          startTime.setHours(now.getHours() - 1);\n          break;\n        case '24h':\n          startTime.setDate(now.getDate() - 1);\n          break;\n        case '7d':\n          startTime.setDate(now.getDate() - 7);\n          break;\n        case '30d':\n          startTime.setDate(now.getDate() - 30);\n          break;\n      }\n\n      const response = await axios.get(`${TWITTER_API_BASE_URL}/tweets/search/recent`, {\n        headers: {\n          'Authorization': `Bearer ${TWITTER_API_KEY}`,\n        },\n        params: {\n          query: searchTerm,\n          'start_time': startTime.toISOString(),\n          'tweet.fields': 'created_at,author_id',\n          'user.fields': 'username',\n          'max_results': 100,\n        },\n      });\n\n      return response.data.data.map((tweet: any) => ({\n        id: tweet.id,\n        text: tweet.text,\n        created_at: tweet.created_at,\n        author_username: tweet.author_id, // In real implementation, we'd get the actual username\n        sentiment: analyzeSentiment(tweet.text),\n      }));\n      */\n    } catch (error: any) {\n      console.error('Error fetching social media data:', error);\n      \n      if (error.message.includes('fetch') || error.name === 'TypeError') {\n        throw new Error('Backend server is not running. Please start the backend server on port 3001.');\n      }\n      \n      throw new Error(`Failed to fetch social media data for ${searchTerm}: ${error.message}`);\n    }\n  },\n}; "],"mappings":"AAEA,MAAMA,WAAW,GAAG,uBAAuB;AAE3CC,OAAO,CAACC,GAAG,CAAC,sBAAsB,CAAC;AACnCD,OAAO,CAACC,GAAG,CAAC,cAAc,EAAEF,WAAW,CAAC;AACxCC,OAAO,CAACC,GAAG,CAAC,mEAAmE,CAAC;AAEhF,MAAMC,gBAAgB,GAAIC,IAAY,IAAqB;EACzD;EACA;EACA,MAAMC,aAAa,GAAG,CAAC,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,WAAW,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,CAAC;EAC/F,MAAMC,aAAa,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,CAAC;EAE7F,MAAMC,KAAK,GAAGH,IAAI,CAACI,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,KAAK,CAAC;EAC7C,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,aAAa,GAAG,CAAC;EACrB,IAAIC,aAAa,GAAG,CAAC;EAErBL,KAAK,CAACM,OAAO,CAACC,IAAI,IAAI;IACpB,IAAIT,aAAa,CAACU,QAAQ,CAACD,IAAI,CAAC,EAAEH,aAAa,EAAE;IACjD,IAAIL,aAAa,CAACS,QAAQ,CAACD,IAAI,CAAC,EAAEF,aAAa,EAAE;EACnD,CAAC,CAAC;EAEFF,KAAK,GAAG,CAACC,aAAa,GAAGC,aAAa,KAAKD,aAAa,GAAGC,aAAa,IAAI,CAAC,CAAC;EAE9E,OAAO;IACLF,KAAK,EAAEM,IAAI,CAACC,GAAG,CAAC,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,EAAER,KAAK,CAAC,CAAC;IAAE;IACzCS,KAAK,EAAET,KAAK,GAAG,GAAG,GAAG,UAAU,GAAGA,KAAK,GAAG,CAAC,GAAG,GAAG,UAAU,GAAG,SAAS;IACvEU,UAAU,EAAEJ,IAAI,CAACK,GAAG,CAACX,KAAK;EAC5B,CAAC;AACH,CAAC;AAED,OAAO,MAAMY,aAAa,GAAG;EAC3B,MAAMC,cAAcA,CAACC,UAAkB,EAAoB;IACzD,IAAI;MACFvB,OAAO,CAACC,GAAG,CAAC,6CAA6CsB,UAAU,EAAE,CAAC;;MAEtE;MACA,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAG1B,WAAW,eAAe2B,kBAAkB,CAACH,UAAU,CAAC,EAAE,EAAE;QAC1FI,MAAM,EAAE,KAAK;QACbC,OAAO,EAAE;UACP,cAAc,EAAE;QAClB;MACF,CAAC,CAAC;MAEF5B,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAEuB,QAAQ,CAACK,MAAM,CAAC;MAExD,IAAI,CAACL,QAAQ,CAACM,EAAE,EAAE;QAChB,MAAMC,SAAS,GAAG,MAAMP,QAAQ,CAACQ,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,OAAO;UAAEC,KAAK,EAAE;QAAgB,CAAC,CAAC,CAAC;QACjF,MAAM,IAAIC,KAAK,CAACJ,SAAS,CAACG,KAAK,IAAI,QAAQV,QAAQ,CAACK,MAAM,KAAKL,QAAQ,CAACY,UAAU,EAAE,CAAC;MACvF;MAEA,MAAMC,WAAW,GAAG,MAAMb,QAAQ,CAACQ,IAAI,CAAC,CAAC;MACzChC,OAAO,CAACC,GAAG,CAAC,YAAYoC,WAAW,CAACC,MAAM,gCAAgCf,UAAU,EAAE,CAAC;;MAEvF;MACA,MAAMgB,eAAwB,GAAGF,WAAW,CAACG,GAAG,CAAC,CAACC,IAAS,EAAEC,KAAa;QAAA,IAAAC,eAAA,EAAAC,gBAAA;QAAA,OAAM;UAC9EC,EAAE,EAAEJ,IAAI,CAACI,EAAE,IAAIH,KAAK,CAACI,QAAQ,CAAC,CAAC;UAC/B3C,IAAI,EAAEsC,IAAI,CAACtC,IAAI;UACf4C,WAAW,EAAEN,IAAI,CAACM,WAAW;UAC7BC,MAAM,EAAEP,IAAI,CAACO,MAAM;UACnBC,SAAS,EAAER,IAAI,CAACQ,SAAS;UACzBC,MAAM,EAAET,IAAI,CAACS,MAAM;UACnBC,GAAG,EAAEV,IAAI,CAACU,GAAG;UACb1C,KAAK,EAAEgC,IAAI,CAAChC,KAAK;UACjB2C,QAAQ,EAAE,QAAQ;UAClBC,SAAS,EAAE;YACTnC,KAAK,EAAE,EAAAyB,eAAA,GAAAF,IAAI,CAACY,SAAS,cAAAV,eAAA,uBAAdA,eAAA,CAAgBzB,KAAK,KAAI,SAAS;YACzCT,KAAK,EAAE,EAAAmC,gBAAA,GAAAH,IAAI,CAACY,SAAS,cAAAT,gBAAA,uBAAdA,gBAAA,CAAgBnC,KAAK,KAAI;UAClC,CAAC;UACD6C,SAAS,EAAEb,IAAI,CAACa;QAClB,CAAC;MAAA,CAAC,CAAC;MAEHtD,OAAO,CAACC,GAAG,CAAC,aAAasC,eAAe,CAACD,MAAM,0BAA0B,CAAC;MAC1E,OAAOC,eAAe;;MAEtB;MACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAGI,CAAC,CAAC,OAAOL,KAAU,EAAE;MACnBlC,OAAO,CAACkC,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MAEzD,IAAIA,KAAK,CAACqB,OAAO,CAACzC,QAAQ,CAAC,OAAO,CAAC,IAAIoB,KAAK,CAACsB,IAAI,KAAK,WAAW,EAAE;QACjE,MAAM,IAAIrB,KAAK,CAAC,8EAA8E,CAAC;MACjG;MAEA,MAAM,IAAIA,KAAK,CAAC,yCAAyCZ,UAAU,KAAKW,KAAK,CAACqB,OAAO,EAAE,CAAC;IAC1F;EACF;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}