{"ast":null,"code":"const BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:3001';\nexport const socialService = {\n  async getSocialPosts(searchTerm) {\n    try {\n      // call backend for social media data from reddit\n      const response = await fetch(`${BACKEND_URL}/api/social/${encodeURIComponent(searchTerm)}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({\n          error: 'Unknown error'\n        }));\n        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);\n      }\n      const socialResponse = await response.json();\n      console.log('Social Service: Raw response:', socialResponse);\n\n      // Handle the response format: {posts: [...]} or {posts: [], message: \"...\", isBlocked: true}\n      const socialPosts = socialResponse.posts || [];\n      if (socialResponse.isBlocked || socialPosts.length === 0) {\n        console.log('Social Service: Reddit data blocked or empty, returning empty array');\n        return [];\n      }\n\n      // convert reddit posts to tweet format for compatibility\n      const socialPostsConverted = socialPosts.map((post, index) => ({\n        id: post.id || index.toString(),\n        text: post.text || post.title || 'No content',\n        url: post.url,\n        author: post.author || 'unknown',\n        createdAt: post.createdAt || new Date().toISOString(),\n        sentiment: post.sentiment || 0,\n        // Reddit backend returns numeric sentiment\n        summary: post.summary\n      }));\n      console.log('Social Service: Converted posts:', socialPostsConverted.length, 'items');\n      return socialPostsConverted;\n\n      // note: twitter api stuff commented out for now\n      /*\n      // Calculate start_time based on timeRange\n      const now = new Date();\n      const startTime = new Date(now.getTime());\n      \n      switch (timeRange) {\n        case '1h':\n          startTime.setHours(now.getHours() - 1);\n          break;\n        case '24h':\n          startTime.setDate(now.getDate() - 1);\n          break;\n        case '7d':\n          startTime.setDate(now.getDate() - 7);\n          break;\n        case '30d':\n          startTime.setDate(now.getDate() - 30);\n          break;\n      }\n       const response = await axios.get(`${TWITTER_API_BASE_URL}/tweets/search/recent`, {\n        headers: {\n          'Authorization': `Bearer ${TWITTER_API_KEY}`,\n          'Content-Type': 'application/json',\n        },\n        params: {\n          query: searchTerm,\n          'tweet.fields': 'created_at,author_id,public_metrics',\n          'user.fields': 'username',\n          'expansions': 'author_id',\n          'start_time': startTime.toISOString(),\n          'max_results': 10,\n        },\n      });\n       const { data: tweets, includes } = response.data;\n      \n      if (!tweets || tweets.length === 0) {\n        return [];\n      }\n       // Map users for easier lookup\n      const usersMap = (includes?.users || []).reduce((acc: any, user: any) => {\n        acc[user.id] = user;\n        return acc;\n      }, {});\n       // Convert Twitter data to our format\n      const convertedTweets: Tweet[] = tweets.map((tweet: any) => {\n        const author = usersMap[tweet.author_id];\n        \n        return {\n          id: tweet.id,\n          text: tweet.text,\n          url: `https://twitter.com/${author?.username}/status/${tweet.id}`,\n          author: author?.username || 'Unknown',\n          createdAt: tweet.created_at,\n          sentiment: 0, // We'll calculate this separately\n        };\n      });\n       return convertedTweets;\n      */\n    } catch (error) {\n      console.error('Error fetching social posts:', error);\n      if (error.message.includes('fetch') || error.name === 'TypeError') {\n        throw new Error('Backend server is not running. Please start the backend server on port 3001.');\n      }\n      throw new Error(`Failed to fetch social posts for ${searchTerm}: ${error.message}`);\n    }\n  }\n};","map":{"version":3,"names":["BACKEND_URL","process","env","REACT_APP_BACKEND_URL","socialService","getSocialPosts","searchTerm","response","fetch","encodeURIComponent","method","headers","ok","errorData","json","catch","error","Error","status","statusText","socialResponse","console","log","socialPosts","posts","isBlocked","length","socialPostsConverted","map","post","index","id","toString","text","title","url","author","createdAt","Date","toISOString","sentiment","summary","message","includes","name"],"sources":["/Users/alexanderalmanza/current/src/services/socialService.ts"],"sourcesContent":["import { Tweet } from '../types';\n\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:3001';\n\nexport const socialService = {\n  async getSocialPosts(searchTerm: string): Promise<Tweet[]> {\n    try {\n      // call backend for social media data from reddit\n      const response = await fetch(`${BACKEND_URL}/api/social/${encodeURIComponent(searchTerm)}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));\n        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const socialResponse = await response.json();\n      console.log('Social Service: Raw response:', socialResponse);\n      \n      // Handle the response format: {posts: [...]} or {posts: [], message: \"...\", isBlocked: true}\n      const socialPosts = socialResponse.posts || [];\n      \n      if (socialResponse.isBlocked || socialPosts.length === 0) {\n        console.log('Social Service: Reddit data blocked or empty, returning empty array');\n        return [];\n      }\n      \n      // convert reddit posts to tweet format for compatibility\n      const socialPostsConverted: Tweet[] = socialPosts.map((post: any, index: number) => ({\n        id: post.id || index.toString(),\n        text: post.text || post.title || 'No content',\n        url: post.url,\n        author: post.author || 'unknown',\n        createdAt: post.createdAt || new Date().toISOString(),\n        sentiment: post.sentiment || 0, // Reddit backend returns numeric sentiment\n        summary: post.summary,\n      }));\n\n      console.log('Social Service: Converted posts:', socialPostsConverted.length, 'items');\n      return socialPostsConverted;\n      \n      // note: twitter api stuff commented out for now\n      /*\n      // Calculate start_time based on timeRange\n      const now = new Date();\n      const startTime = new Date(now.getTime());\n      \n      switch (timeRange) {\n        case '1h':\n          startTime.setHours(now.getHours() - 1);\n          break;\n        case '24h':\n          startTime.setDate(now.getDate() - 1);\n          break;\n        case '7d':\n          startTime.setDate(now.getDate() - 7);\n          break;\n        case '30d':\n          startTime.setDate(now.getDate() - 30);\n          break;\n      }\n\n      const response = await axios.get(`${TWITTER_API_BASE_URL}/tweets/search/recent`, {\n        headers: {\n          'Authorization': `Bearer ${TWITTER_API_KEY}`,\n          'Content-Type': 'application/json',\n        },\n        params: {\n          query: searchTerm,\n          'tweet.fields': 'created_at,author_id,public_metrics',\n          'user.fields': 'username',\n          'expansions': 'author_id',\n          'start_time': startTime.toISOString(),\n          'max_results': 10,\n        },\n      });\n\n      const { data: tweets, includes } = response.data;\n      \n      if (!tweets || tweets.length === 0) {\n        return [];\n      }\n\n      // Map users for easier lookup\n      const usersMap = (includes?.users || []).reduce((acc: any, user: any) => {\n        acc[user.id] = user;\n        return acc;\n      }, {});\n\n      // Convert Twitter data to our format\n      const convertedTweets: Tweet[] = tweets.map((tweet: any) => {\n        const author = usersMap[tweet.author_id];\n        \n        return {\n          id: tweet.id,\n          text: tweet.text,\n          url: `https://twitter.com/${author?.username}/status/${tweet.id}`,\n          author: author?.username || 'Unknown',\n          createdAt: tweet.created_at,\n          sentiment: 0, // We'll calculate this separately\n        };\n      });\n\n      return convertedTweets;\n      */\n    } catch (error: any) {\n      console.error('Error fetching social posts:', error);\n      \n      if (error.message.includes('fetch') || error.name === 'TypeError') {\n        throw new Error('Backend server is not running. Please start the backend server on port 3001.');\n      }\n      \n      throw new Error(`Failed to fetch social posts for ${searchTerm}: ${error.message}`);\n    }\n  },\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}