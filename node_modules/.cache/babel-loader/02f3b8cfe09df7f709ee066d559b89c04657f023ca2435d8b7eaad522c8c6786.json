{"ast":null,"code":"const TWITTER_API_KEY = process.env.REACT_APP_TWITTER_API_KEY;\nconst TWITTER_API_BASE_URL = 'https://api.twitter.com/2';\nconsole.log('TwitterService Debug:');\nconsole.log('Twitter API Key available:', TWITTER_API_KEY ? 'YES' : 'NO');\nconst analyzeSentiment = text => {\n  // Simple sentiment analysis based on keyword matching\n  // In a production environment, you'd want to use a proper NLP service\n  const positiveWords = ['great', 'good', 'awesome', 'excellent', 'up', 'gain', 'profit', 'bull'];\n  const negativeWords = ['bad', 'poor', 'terrible', 'down', 'loss', 'bear', 'crash', 'decline'];\n  const words = text.toLowerCase().split(/\\s+/);\n  let score = 0;\n  let positiveCount = 0;\n  let negativeCount = 0;\n  words.forEach(word => {\n    if (positiveWords.includes(word)) positiveCount++;\n    if (negativeWords.includes(word)) negativeCount++;\n  });\n  score = (positiveCount - negativeCount) / (positiveCount + negativeCount || 1);\n  return {\n    score: Math.max(-1, Math.min(1, score)),\n    // Clamp between -1 and 1\n    label: score > 0.1 ? 'positive' : score < -0.1 ? 'negative' : 'neutral',\n    confidence: Math.abs(score)\n  };\n};\nexport const twitterService = {\n  async getTweets(searchTerm, timeRange) {\n    try {\n      console.log(`Fetching tweets for term: ${searchTerm}, timeRange: ${timeRange}`);\n\n      // For now, return mock data to avoid Twitter API issues\n      // Twitter API v2 requires elevated access for search functionality\n      const mockTweets = [{\n        id: '1',\n        text: `Just bought more ${searchTerm}! Great investment opportunity. #bullish`,\n        created_at: new Date().toISOString(),\n        author_username: 'investor123',\n        sentiment: analyzeSentiment(`Just bought more ${searchTerm}! Great investment opportunity. #bullish`)\n      }, {\n        id: '2',\n        text: `${searchTerm} looking bearish today. Might be time to sell.`,\n        created_at: new Date(Date.now() - 3600000).toISOString(),\n        author_username: 'trader_pro',\n        sentiment: analyzeSentiment(`${searchTerm} looking bearish today. Might be time to sell.`)\n      }, {\n        id: '3',\n        text: `Neutral outlook on ${searchTerm} for this quarter.`,\n        created_at: new Date(Date.now() - 7200000).toISOString(),\n        author_username: 'market_analyst',\n        sentiment: analyzeSentiment(`Neutral outlook on ${searchTerm} for this quarter.`)\n      }];\n      console.log(`Returning ${mockTweets.length} mock tweets`);\n      return mockTweets;\n\n      // TODO: Uncomment below when Twitter API access is properly configured\n      /*\n      // Calculate start_time based on timeRange\n      const now = new Date();\n      const startTime = new Date(now.getTime());\n      \n      switch (timeRange) {\n        case '1h':\n          startTime.setHours(now.getHours() - 1);\n          break;\n        case '24h':\n          startTime.setDate(now.getDate() - 1);\n          break;\n        case '7d':\n          startTime.setDate(now.getDate() - 7);\n          break;\n        case '30d':\n          startTime.setDate(now.getDate() - 30);\n          break;\n      }\n       const response = await axios.get(`${TWITTER_API_BASE_URL}/tweets/search/recent`, {\n        headers: {\n          'Authorization': `Bearer ${TWITTER_API_KEY}`,\n        },\n        params: {\n          query: searchTerm,\n          'start_time': startTime.toISOString(),\n          'tweet.fields': 'created_at,author_id',\n          'user.fields': 'username',\n          'max_results': 100,\n        },\n      });\n       return response.data.data.map((tweet: any) => ({\n        id: tweet.id,\n        text: tweet.text,\n        created_at: tweet.created_at,\n        author_username: tweet.author_id, // In real implementation, we'd get the actual username\n        sentiment: analyzeSentiment(tweet.text),\n      }));\n      */\n    } catch (error) {\n      var _response, _response2;\n      console.error('Error fetching tweets:', error);\n      console.error('Twitter API error details:', {\n        message: error.message,\n        response: (_response = error.response) === null || _response === void 0 ? void 0 : _response.data,\n        status: (_response2 = error.response) === null || _response2 === void 0 ? void 0 : _response2.status\n      });\n      throw error;\n    }\n  }\n};","map":{"version":3,"names":["TWITTER_API_KEY","process","env","REACT_APP_TWITTER_API_KEY","TWITTER_API_BASE_URL","console","log","analyzeSentiment","text","positiveWords","negativeWords","words","toLowerCase","split","score","positiveCount","negativeCount","forEach","word","includes","Math","max","min","label","confidence","abs","twitterService","getTweets","searchTerm","timeRange","mockTweets","id","created_at","Date","toISOString","author_username","sentiment","now","length","error","_response","_response2","message","response","data","status"],"sources":["/Users/loaneruser/Documents/GitHub/current/src/services/twitterService.ts"],"sourcesContent":["import { Tweet, SentimentScore } from '../types';\n\nconst TWITTER_API_KEY = process.env.REACT_APP_TWITTER_API_KEY;\nconst TWITTER_API_BASE_URL = 'https://api.twitter.com/2';\n\nconsole.log('TwitterService Debug:');\nconsole.log('Twitter API Key available:', TWITTER_API_KEY ? 'YES' : 'NO');\n\nconst analyzeSentiment = (text: string): SentimentScore => {\n  // Simple sentiment analysis based on keyword matching\n  // In a production environment, you'd want to use a proper NLP service\n  const positiveWords = ['great', 'good', 'awesome', 'excellent', 'up', 'gain', 'profit', 'bull'];\n  const negativeWords = ['bad', 'poor', 'terrible', 'down', 'loss', 'bear', 'crash', 'decline'];\n\n  const words = text.toLowerCase().split(/\\s+/);\n  let score = 0;\n  let positiveCount = 0;\n  let negativeCount = 0;\n\n  words.forEach(word => {\n    if (positiveWords.includes(word)) positiveCount++;\n    if (negativeWords.includes(word)) negativeCount++;\n  });\n\n  score = (positiveCount - negativeCount) / (positiveCount + negativeCount || 1);\n  \n  return {\n    score: Math.max(-1, Math.min(1, score)), // Clamp between -1 and 1\n    label: score > 0.1 ? 'positive' : score < -0.1 ? 'negative' : 'neutral',\n    confidence: Math.abs(score),\n  };\n};\n\nexport const twitterService = {\n  async getTweets(searchTerm: string, timeRange: string): Promise<Tweet[]> {\n    try {\n      console.log(`Fetching tweets for term: ${searchTerm}, timeRange: ${timeRange}`);\n      \n      // For now, return mock data to avoid Twitter API issues\n      // Twitter API v2 requires elevated access for search functionality\n      const mockTweets: Tweet[] = [\n        {\n          id: '1',\n          text: `Just bought more ${searchTerm}! Great investment opportunity. #bullish`,\n          created_at: new Date().toISOString(),\n          author_username: 'investor123',\n          sentiment: analyzeSentiment(`Just bought more ${searchTerm}! Great investment opportunity. #bullish`),\n        },\n        {\n          id: '2',\n          text: `${searchTerm} looking bearish today. Might be time to sell.`,\n          created_at: new Date(Date.now() - 3600000).toISOString(),\n          author_username: 'trader_pro',\n          sentiment: analyzeSentiment(`${searchTerm} looking bearish today. Might be time to sell.`),\n        },\n        {\n          id: '3',\n          text: `Neutral outlook on ${searchTerm} for this quarter.`,\n          created_at: new Date(Date.now() - 7200000).toISOString(),\n          author_username: 'market_analyst',\n          sentiment: analyzeSentiment(`Neutral outlook on ${searchTerm} for this quarter.`),\n        },\n      ];\n\n      console.log(`Returning ${mockTweets.length} mock tweets`);\n      return mockTweets;\n      \n      // TODO: Uncomment below when Twitter API access is properly configured\n      /*\n      // Calculate start_time based on timeRange\n      const now = new Date();\n      const startTime = new Date(now.getTime());\n      \n      switch (timeRange) {\n        case '1h':\n          startTime.setHours(now.getHours() - 1);\n          break;\n        case '24h':\n          startTime.setDate(now.getDate() - 1);\n          break;\n        case '7d':\n          startTime.setDate(now.getDate() - 7);\n          break;\n        case '30d':\n          startTime.setDate(now.getDate() - 30);\n          break;\n      }\n\n      const response = await axios.get(`${TWITTER_API_BASE_URL}/tweets/search/recent`, {\n        headers: {\n          'Authorization': `Bearer ${TWITTER_API_KEY}`,\n        },\n        params: {\n          query: searchTerm,\n          'start_time': startTime.toISOString(),\n          'tweet.fields': 'created_at,author_id',\n          'user.fields': 'username',\n          'max_results': 100,\n        },\n      });\n\n      return response.data.data.map((tweet: any) => ({\n        id: tweet.id,\n        text: tweet.text,\n        created_at: tweet.created_at,\n        author_username: tweet.author_id, // In real implementation, we'd get the actual username\n        sentiment: analyzeSentiment(tweet.text),\n      }));\n      */\n    } catch (error) {\n      console.error('Error fetching tweets:', error);\n      console.error('Twitter API error details:', {\n        message: (error as any).message,\n        response: (error as any).response?.data,\n        status: (error as any).response?.status,\n      });\n      throw error;\n    }\n  },\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}