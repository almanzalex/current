{"ast":null,"code":"const BACKEND_URL = 'http://localhost:3001';\nexport const socialService = {\n  async getSocialPosts(searchTerm) {\n    try {\n      // call backend for social media data from reddit\n      const response = await fetch(`${BACKEND_URL}/api/social/${encodeURIComponent(searchTerm)}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({\n          error: 'Unknown error'\n        }));\n        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);\n      }\n      const socialPosts = await response.json();\n\n      // convert reddit posts to tweet format for compatibility\n      const socialPostsConverted = socialPosts.map((post, index) => {\n        var _post$sentiment, _post$sentiment2;\n        return {\n          id: post.id || index.toString(),\n          text: post.text,\n          description: post.description,\n          author: post.author,\n          createdAt: post.createdAt,\n          source: post.source,\n          url: post.url,\n          score: post.score,\n          platform: 'reddit',\n          sentiment: {\n            label: ((_post$sentiment = post.sentiment) === null || _post$sentiment === void 0 ? void 0 : _post$sentiment.label) || 'neutral',\n            score: ((_post$sentiment2 = post.sentiment) === null || _post$sentiment2 === void 0 ? void 0 : _post$sentiment2.score) || 0\n          },\n          aiSummary: post.aiSummary\n        };\n      });\n      return socialPostsConverted;\n\n      // note: twitter api stuff commented out for now\n      /*\n      // Calculate start_time based on timeRange\n      const now = new Date();\n      const startTime = new Date(now.getTime());\n      \n      switch (timeRange) {\n        case '1h':\n          startTime.setHours(now.getHours() - 1);\n          break;\n        case '24h':\n          startTime.setDate(now.getDate() - 1);\n          break;\n        case '7d':\n          startTime.setDate(now.getDate() - 7);\n          break;\n        case '30d':\n          startTime.setDate(now.getDate() - 30);\n          break;\n      }\n       const response = await axios.get(`${TWITTER_API_BASE_URL}/tweets/search/recent`, {\n        headers: {\n          'Authorization': `Bearer ${TWITTER_API_KEY}`,\n        },\n        params: {\n          query: searchTerm,\n          'start_time': startTime.toISOString(),\n          'tweet.fields': 'created_at,author_id',\n          'user.fields': 'username',\n          'max_results': 100,\n        },\n      });\n       return response.data.data.map((tweet: any) => ({\n        id: tweet.id,\n        text: tweet.text,\n        created_at: tweet.created_at,\n        author_username: tweet.author_id, // In real implementation, we'd get the actual username\n        sentiment: analyzeSentiment(tweet.text),\n      }));\n      */\n    } catch (error) {\n      console.error('Error fetching social media data:', error);\n      if (error.message.includes('fetch') || error.name === 'TypeError') {\n        throw new Error('Backend server is not running. Please start the backend server on port 3001.');\n      }\n      throw new Error(`Failed to fetch social media data for ${searchTerm}: ${error.message}`);\n    }\n  }\n};","map":{"version":3,"names":["BACKEND_URL","socialService","getSocialPosts","searchTerm","response","fetch","encodeURIComponent","method","headers","ok","errorData","json","catch","error","Error","status","statusText","socialPosts","socialPostsConverted","map","post","index","_post$sentiment","_post$sentiment2","id","toString","text","description","author","createdAt","source","url","score","platform","sentiment","label","aiSummary","console","message","includes","name"],"sources":["/Users/alexanderalmanza/current/src/services/socialService.ts"],"sourcesContent":["import { Tweet } from '../types';\n\nconst BACKEND_URL = 'http://localhost:3001';\n\n\n\n\n\nexport const socialService = {\n  async getSocialPosts(searchTerm: string): Promise<Tweet[]> {\n    try {\n      // call backend for social media data from reddit\n      const response = await fetch(`${BACKEND_URL}/api/social/${encodeURIComponent(searchTerm)}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));\n        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const socialPosts = await response.json();\n      \n      // convert reddit posts to tweet format for compatibility\n      const socialPostsConverted: Tweet[] = socialPosts.map((post: any, index: number) => ({\n        id: post.id || index.toString(),\n        text: post.text,\n        description: post.description,\n        author: post.author,\n        createdAt: post.createdAt,\n        source: post.source,\n        url: post.url,\n        score: post.score,\n        platform: 'reddit',\n        sentiment: {\n          label: post.sentiment?.label || 'neutral',\n          score: post.sentiment?.score || 0,\n        },\n        aiSummary: post.aiSummary,\n      }));\n\n      return socialPostsConverted;\n      \n      // note: twitter api stuff commented out for now\n      /*\n      // Calculate start_time based on timeRange\n      const now = new Date();\n      const startTime = new Date(now.getTime());\n      \n      switch (timeRange) {\n        case '1h':\n          startTime.setHours(now.getHours() - 1);\n          break;\n        case '24h':\n          startTime.setDate(now.getDate() - 1);\n          break;\n        case '7d':\n          startTime.setDate(now.getDate() - 7);\n          break;\n        case '30d':\n          startTime.setDate(now.getDate() - 30);\n          break;\n      }\n\n      const response = await axios.get(`${TWITTER_API_BASE_URL}/tweets/search/recent`, {\n        headers: {\n          'Authorization': `Bearer ${TWITTER_API_KEY}`,\n        },\n        params: {\n          query: searchTerm,\n          'start_time': startTime.toISOString(),\n          'tweet.fields': 'created_at,author_id',\n          'user.fields': 'username',\n          'max_results': 100,\n        },\n      });\n\n      return response.data.data.map((tweet: any) => ({\n        id: tweet.id,\n        text: tweet.text,\n        created_at: tweet.created_at,\n        author_username: tweet.author_id, // In real implementation, we'd get the actual username\n        sentiment: analyzeSentiment(tweet.text),\n      }));\n      */\n    } catch (error: any) {\n      console.error('Error fetching social media data:', error);\n      \n      if (error.message.includes('fetch') || error.name === 'TypeError') {\n        throw new Error('Backend server is not running. Please start the backend server on port 3001.');\n      }\n      \n      throw new Error(`Failed to fetch social media data for ${searchTerm}: ${error.message}`);\n    }\n  },\n}; "],"mappings":"AAEA,MAAMA,WAAW,GAAG,uBAAuB;AAM3C,OAAO,MAAMC,aAAa,GAAG;EAC3B,MAAMC,cAAcA,CAACC,UAAkB,EAAoB;IACzD,IAAI;MACF;MACA,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGL,WAAW,eAAeM,kBAAkB,CAACH,UAAU,CAAC,EAAE,EAAE;QAC1FI,MAAM,EAAE,KAAK;QACbC,OAAO,EAAE;UACP,cAAc,EAAE;QAClB;MACF,CAAC,CAAC;MAEF,IAAI,CAACJ,QAAQ,CAACK,EAAE,EAAE;QAChB,MAAMC,SAAS,GAAG,MAAMN,QAAQ,CAACO,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,OAAO;UAAEC,KAAK,EAAE;QAAgB,CAAC,CAAC,CAAC;QACjF,MAAM,IAAIC,KAAK,CAACJ,SAAS,CAACG,KAAK,IAAI,QAAQT,QAAQ,CAACW,MAAM,KAAKX,QAAQ,CAACY,UAAU,EAAE,CAAC;MACvF;MAEA,MAAMC,WAAW,GAAG,MAAMb,QAAQ,CAACO,IAAI,CAAC,CAAC;;MAEzC;MACA,MAAMO,oBAA6B,GAAGD,WAAW,CAACE,GAAG,CAAC,CAACC,IAAS,EAAEC,KAAa;QAAA,IAAAC,eAAA,EAAAC,gBAAA;QAAA,OAAM;UACnFC,EAAE,EAAEJ,IAAI,CAACI,EAAE,IAAIH,KAAK,CAACI,QAAQ,CAAC,CAAC;UAC/BC,IAAI,EAAEN,IAAI,CAACM,IAAI;UACfC,WAAW,EAAEP,IAAI,CAACO,WAAW;UAC7BC,MAAM,EAAER,IAAI,CAACQ,MAAM;UACnBC,SAAS,EAAET,IAAI,CAACS,SAAS;UACzBC,MAAM,EAAEV,IAAI,CAACU,MAAM;UACnBC,GAAG,EAAEX,IAAI,CAACW,GAAG;UACbC,KAAK,EAAEZ,IAAI,CAACY,KAAK;UACjBC,QAAQ,EAAE,QAAQ;UAClBC,SAAS,EAAE;YACTC,KAAK,EAAE,EAAAb,eAAA,GAAAF,IAAI,CAACc,SAAS,cAAAZ,eAAA,uBAAdA,eAAA,CAAgBa,KAAK,KAAI,SAAS;YACzCH,KAAK,EAAE,EAAAT,gBAAA,GAAAH,IAAI,CAACc,SAAS,cAAAX,gBAAA,uBAAdA,gBAAA,CAAgBS,KAAK,KAAI;UAClC,CAAC;UACDI,SAAS,EAAEhB,IAAI,CAACgB;QAClB,CAAC;MAAA,CAAC,CAAC;MAEH,OAAOlB,oBAAoB;;MAE3B;MACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAGI,CAAC,CAAC,OAAOL,KAAU,EAAE;MACnBwB,OAAO,CAACxB,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MAEzD,IAAIA,KAAK,CAACyB,OAAO,CAACC,QAAQ,CAAC,OAAO,CAAC,IAAI1B,KAAK,CAAC2B,IAAI,KAAK,WAAW,EAAE;QACjE,MAAM,IAAI1B,KAAK,CAAC,8EAA8E,CAAC;MACjG;MAEA,MAAM,IAAIA,KAAK,CAAC,yCAAyCX,UAAU,KAAKU,KAAK,CAACyB,OAAO,EAAE,CAAC;IAC1F;EACF;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}